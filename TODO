1. Try having an in memory cache for single resources like movie, actor, credits etc...
1. XXX Basic implementation done, check wheter to clear after a certain size or time XXX
2. Use Event Emitters to log and/or process data/errors eg. const EventEmitter = require('events'); emm = new EventEmitter(); emm.on('eventName', function)
3. Try #2 with setImmediate for async
4. Have a better folder structure for sequelize!!!
XXX Done using sequelize-cli XXX

For auth:
1. Decide how to hash the passwords, either with bcrypt or argon2, the latter is protected against time attacks
2. Evaluate if I need passportJS or instead create myself a middleware
3a. Implement JWT
3b. Invalidate JWT or cookies after a while
3c. should send back the token on register or ask to signIn
4. In the end the only unprotected routes will be the auth ones










sequelizeCLI:
https://medium.com/@andrewoons/how-to-define-sequelize-associations-using-migrations-de4333bf75a7

with sequelize-cli we can create a model/migration, which creates a index.js that will export the entire db object!
We can just import that wherever we need it.
Just remember to do a sequelize db:migrate the first time.


```
    const db = require("../../../models")
    
  await db.User.create({firstName: 'AAA', email: 'email@test.com', passwordDigest: 'asdasda'})
  await db.UserFavourite.create({movieRefId: 2243,movieTitle: "adasd",userId: 2,moviePosterPath:"asdada"})
  await db.UserFavourite.create({movieRefId: 22343,movieTitle: "aASDASDdasd",userId: 3,moviePosterPath:"aDGARREFEEFsdada"})
  const usQ = await db.User.findByPk(1)
  const usFav = await usQ.getUserFavourites()
```